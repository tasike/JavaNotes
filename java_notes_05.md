# JAVA NOTES（Part 5）==by tasike==

- ## 原码、反码、补码

- ## 一些小知识的具体说明，隐式转换，强制转换，按位与，按位或,左移，右移，无符号右移，无符号左移

---------------------

## 一、原码、反码、补码

### 1.定义：十进制数据的二进制表现形式，最左边是符号位，0为正，1为负

### 				               正数的反码是其本身，负数是反码是符号位不变，其余为取反

### 			   正数的补码是其本身，负数的补码是在其反码的基础上+1

### 2.什么是原码？

```
56的原码是00111000，一个0或者一个1称为一个bit(比特位)，一个字节有8个比特位。

那么一个字节的最大值可以达到01111111，即2^0+2^1+2^2+2^3+2^4+2^5+2^6 = 2^7 - 1 = 127
    一个字节的最小值可以达到11111111，即-2^0-2^1-2^2-2^3-2^4-2^5-2^6 = -(2^7 - 1) = -127，
然而事实上一个字节的最小是可以达到-128，具体原因下面会提到。

对于正数的原码：00000000就是0，加1后00000001就是1，再加1后00000010就是2,........
利用原码对正数计算是不会有任何问题的

然而对于负数的原码：10000000是0，加1后10000001却是-1
因此，利用原码对负数进行运算有问题

为了解决原码不能计算负数的问题，反码出现了
-56的原码是10111000，其反码是11000111，接下来验证一下-56+1是否能得到-55
11000111+1=11001000，该反码对应的十进制就是-55

但是，有个小问题，-1的反码是11111110，加1之后，得到反码11111111，该反码对应的十进制是0，还是没有问题。然而，再加1的话，得到00000000，该反码对应的十进制还是0，出现了问题。凡是跨0的计算都会出现误差。

为了解决反码进行跨0的计算时出现的误差，补码出现了
由于+0和-0的反码有2个(00000000，11111111)，因此考虑错开一个，让+0和-0的补码都是00000000，11111111给下面的-1，依次类推，得到补码的表
```

| 十进制数字 | 原码      | 反码      | 补码      |
| ---------- | --------- | --------- | --------- |
| +0         | 0000 0000 | 0000 0000 | 0000 0000 |
| -0         | 1000 0000 | 1111 1111 | 0000 0000 |
| -1         | 1000 0001 | 1111 1110 | 1111 1111 |
| -2         | 1000 0010 | 1111 1101 | 1111 1110 |
| -3         | 1000 0011 | 1111 1100 | 1111 1101 |

```
然而，这么一弄，-127的反码往下错开一位得到-128的补码，因此一个字节的最小值可以达到-128，并且-128没有原码和补码，如下：
```

| 十进制数字 | 原码      | 反码      | 补码      |
| ---------- | --------- | --------- | --------- |
| -126       | 1111 1110 | 1000 0001 | 1000 0010 |
| -127       | 1111 1111 | 1000 0000 | 1000 0001 |
| -128       | 无        | 无        | 1000 0000 |

```
因此，一个字节的取值范围是-128~127，计算机中数字的存储和计算都是以补码的形式进行操作的
```

### 3.说回基本数据类型

byte的10: 1个字节  0000 1010

short的10: 2个字节 0000 0000 0000 1010

int的10：4个字节    0000 0000 0000 0000 0000 0000 0000 1010

long的10：8个字节 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 1010

==隐式转换(自动类型转换)==

```java
public class ImplicitConversion{
    public static void main(String[] args){
        byte a = 10;//0000 1010
        int b = a;//0000 0000 0000 0000 0000 0000 0000 1010
        System.out.println(b);
    }
}
```

> 如上面代码中的注释所示，隐式转换的操作不会产生误差

==强制类型转换==

```java
public class ForceConversion{
    public static void main(String[] args){
        int a = 200;//0000 0000 0000 0000 0000 0000 1100 1000
        byte b = (byte)a;//直接截断，1100 1000，对应的十进制为-56
        System.out.println(b);
    }
} 
```

> 如上面代码中的注释所示，强制转换的操作在超过其转换类型的最大存储范围时会出现误差

### 3.按位与，按位或，左移，右移，无符号右移，无符号左移

#### 	==(左移，右移属于算术移动，无符号右移，无符号左移属于逻辑移动)==

```java
按位与运算符：&
0&0=0  0&1=0  1&0=0  1&1=1
例如：
public class Test{
    public static void main(String[] args){
        int a = 200;//0000 0000 0000 0000 0000 0000 1100 1000
		int b = 10; //0000 0000 0000 0000 0000 0000 0000 1010
        System.out.println(a&b);
    }
}
```

> 运行结果：
> 8 ==0000 0000 0000 0000 0000 0000 0000 1000==

```java
按位或运算符：|
0|0=0  0|1=1  1|0=1  1|1=1
例如：
public class Test{
    public static void main(String[] args){
        int a = 200;//0000 0000 0000 0000 0000 0000 1100 1000
		int b = 10; //0000 0000 0000 0000 0000 0000 0000 1010
        System.out.println(a|b);
    }
}
```

> 运行结果：
> 202 ==0000 0000 0000 0000 0000 0000 1100 1010==

```java
左移运算符：<<(向左移动，低位补0)
例如：
public class Test{
    public static void main(String[] args){
        int a = 200;
        System.out.println(a << 3);
    }
}
```

> 运行结果：
> 1600 ==200*2^3==

```java
右移运算符：>>(向右移动，最高位补与原来符号位一样的数字，其余高位补0)
例如：
public class Test{
    public static void main(String[] args){
        int a = 200;
        System.out.println(a >> 3);
    }
}
```

> 运行结果：
> 25 ==200/2^3==

```java
无符号右移运算符：>>>(向右移动，高位补0)
例如：
public class Test{
    public static void main(String[] args){
        int a = -200;
        System.out.println(a >>> 3);
    }
}
```

> 运行结果：
> 536870887

```java
无符号左移运算符：<<<(向左移动，高位补0)
```

